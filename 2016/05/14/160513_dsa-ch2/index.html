<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>第二章 算法分析 • DRAPORLAND</title><meta name="description" content="第二章 算法分析 - Gabriel Drapor"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="https://unpkg.com/nanoreset@3.0.1/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="DRAPORLAND"></head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="DRAPORLAND"><img class="logo-image" src="/logo.svg" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/about-me" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/2018-reading-list" target="_self">READING LIST</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/atom.xml" target="_self">RSS</a></li></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">第二章 算法分析</h1><div class="post-info"><a></a>2016-05-14</div><div class="post-content"><p><strong>2.4.3最大子序列和问题的解</strong></p>
<blockquote>
<p><strong>最大的子序列和问题</strong>：给定整数A1，A2，……，AN（可能有负数），求∑(k=i)^j A_k  的最大值（为方便起见，如果所有整数均为负数，则最大子序列和为0）</p>
</blockquote>
<a id="more"></a>
<p><strong>• 算法3</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//T(N)=O(N log N) </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaxSubSum</span><span class="params">( <span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> Left,<span class="keyword">int</span> Right )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> MaxLeftSum,MaxRightSum;</div><div class="line">	<span class="keyword">int</span> MaxLeftBorderSum,MaxRightBorderSum;</div><div class="line">	<span class="keyword">int</span> LeftBorderSum,RightBorderSum;</div><div class="line">	<span class="keyword">int</span> Center,i;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(Left==Right)   <span class="comment">//Base Case,即'基准情形'</span></div><div class="line">	<span class="keyword">if</span> (A[Left]&gt;<span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> A[Left];</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">	Center = (Left + Right)/<span class="number">2</span>;</div><div class="line">	MaxLeftSum=MaxSubSum(A,Left,Center);<span class="comment">//左边中最大的子序列和</span></div><div class="line">	MaxRightSum=MaxSubSum(A,Center+<span class="number">1</span>,Right);<span class="comment">//右边中最大的子序列和</span></div><div class="line">	MaxLeftBorderSum = <span class="number">0</span>; LeftBorderSum = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(i=Center;i&gt;=Left;i--)<span class="comment">//从中心开始向左找最大子序列和</span></div><div class="line">	&#123;</div><div class="line">		LeftBorderSum+=A[i];</div><div class="line">		<span class="keyword">if</span>(LeftBorderSum&gt;MaxLeftBorderSum)</div><div class="line">		MaxLeftBorderSum= LeftBorderSum;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	MaxRightBorderSum = <span class="number">0</span>; RightBorderSum = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(i=Center+<span class="number">1</span>;i&lt;=Right;i+　+)<span class="comment">//从中心开始向右找最大子序列和</span></div><div class="line">	&#123;</div><div class="line">		RightBorderSum+=A[i];</div><div class="line">		<span class="keyword">if</span>(RightBorderSum&gt;MaxRightBorderSum)</div><div class="line">		MaxRightBorderSum=RightBorderSum;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> Max3(MaxLeftSum,MaxRightSum,MaxLeftBorderSum + MaxRightBorderSum);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubsequenceSum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> MaxSubSum(A , <span class="number">0</span> , N - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max3</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (a&gt;b)</div><div class="line">	<span class="keyword">if</span> (a&gt;c) <span class="keyword">return</span> a;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">return</span> c;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	<span class="keyword">if</span> (c&gt;b) <span class="keyword">return</span> c;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
<p>​</p>
<p><strong>• 更简单有效的算法4</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubsequenceSum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> ThisSum,MaxSum,j;</div><div class="line">	</div><div class="line">	ThisSum=MaxSum=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</div><div class="line">	&#123;</div><div class="line">		ThisSum+=A[j];</div><div class="line">		<span class="keyword">if</span>(ThisSum &gt; MaxSum)</div><div class="line">			MaxSum = ThisSum;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ThisSum &lt; <span class="number">0</span>)  <span class="comment">//这一步是关键，如果前j项和是负的，那就可以扔掉不要了</span></div><div class="line">			ThisSum=<span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">		<span class="keyword">return</span> MaxSum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这种算法的附带优点是，只需要扫描一次数据，一旦A[i]被扫入并被处理，它就不再需要被记忆【5/13:数据赋值等操作少】。在任何时刻，算法都能对它已经读入的数据给出子序列问题的正确答案（其他算法不具有这个特性）【5/13:也就是说，假如你输入的是10个数据，在你输入到任何一个的时候，在这种情况下的解已经被算出来了】。具有这种特性的算法叫做<em>联机算法</em>（online algorithm）。</p>
</blockquote>
<p>​</p>
<p><strong>2.4.4运行时间中的对数</strong></p>
<blockquote>
<p>除分治算法外，可将对数最常出现的规律概括为下列一般法则：如果一个算法用常数时间（O（1））将问题的大小削减为其一部分（通常是1/2），那么该算法就是O（log N）。另一方面，如果使用常数时间只是把问题减少一个常数（如将问题减少1），那么这种算法就是O（N）的。<br>
【5/15:可以理解为就是一个循环中，如果这个算法本身能够自己削减循环次数的话，那么就会从O（N）降到O（log N）】</p>
</blockquote>
<p><strong>• 对分算法</strong><br>
​</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//T(N)=O（log N）</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> Low,Mid,High;</div><div class="line">	Low=<span class="number">0</span>;High=n<span class="number">-1</span>;</div><div class="line">	<span class="keyword">while</span>(Low &lt;= High)</div><div class="line">	&#123;</div><div class="line">		Mid = (Low+High) /<span class="number">2</span>;</div><div class="line">   	       <span class="keyword">if</span>(A[Mid]&lt;x)</div><div class="line">			Low=Mid+<span class="number">1</span>;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(A[Mid]&gt; x)</div><div class="line">		High=Mid<span class="number">-1</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		<span class="keyword">return</span> Mid;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> NotFound;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它提供了在O（log N）时间内的Find（查找）操作。访问次数少，而如果是顺序查找的话就会需要多很多的访问次数。<br>
​	<br>
<strong>• 欧几里德算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> M,<span class="keyword">unsigned</span> <span class="keyword">int</span> N)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> Rem;</div><div class="line">	<span class="keyword">while</span>( N&gt;<span class="number">0</span> )</div><div class="line">	&#123;</div><div class="line">		Rem = M % N;</div><div class="line">		M = N;</div><div class="line">		N = Rem;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> M;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>定理2.1</strong>：如果M &gt; N , 则M mod N &lt; M/2。T（N）=O（log N） 。<br>
​	<br>
<strong>• 幂运算</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//T(N)=O(log N)</span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> X,<span class="keyword">unsigned</span> <span class="keyword">int</span> N)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>( N == <span class="number">0</span> )</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>( N == <span class="number">1</span> )    <span class="comment">/**接下来的两行也可以不写**/</span></div><div class="line">		<span class="keyword">return</span> X;</div><div class="line">	<span class="keyword">if</span>( IsEven( N ) )</div><div class="line">		<span class="keyword">return</span> Pow( X * X, N / <span class="number">2</span> );</div><div class="line">	<span class="comment">/**</span></div><div class="line">	以下的修改都是不可取的:</div><div class="line">	return Pow( Pow( X, 2), N / 2);</div><div class="line">	return Pow( Pow( X, N / 2), 2);</div><div class="line">	-以上这两种会产生无限循环，导致程序崩溃</div><div class="line">	return Pow( X, N / 2)* Pow(X, N / 2 );</div><div class="line">	-这种影响程序的效率【运行时间应该是O（N）(?)】</div><div class="line">	**/</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="keyword">return</span> Pow( X * X, N / <span class="number">2</span> ) * N;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	如果不写N==1那两行的话，上面这行还可以写成</div><div class="line">	return Pow(X,N-1)*X;</div><div class="line">	**/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>“有时候看一看程序能够进行多大的调整而不影响其正确性倒是很有意思的”</strong></p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2016/05/17/160517_re/">prev</a><a class="next" href="/2016/05/13/160513_dsa-ch1/">next</a></div><div class="copyright"><p>&copy; 2015 - 2018 <a href="https://drapor.me">Drapor</a><br>Powered by <a href="https://hexo.io/" rel="noreferrer" target="_blank">Hexo</a></p></div></footer></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>